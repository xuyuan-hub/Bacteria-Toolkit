Index: launch.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import logging\r\nimport os\r\nimport sys\r\nimport cv2\r\nimport shutil\r\nimport datetime\r\nfrom PyQt5.QtWidgets import QApplication,QMainWindow,QFileDialog\r\nfrom PyQt5.QtCore import pyqtSignal,QTimer,QThread\r\nfrom PyQt5 import QtGui\r\n\r\nROOT = os.path.dirname(os.path.abspath(__file__))\r\nif str(ROOT) not in sys.path:\r\n    sys.path.append(str(ROOT))\r\n\r\nfrom GUI.BacteriaToolkit import Ui_mainWindow as ToolkitUi\r\nimport detect\r\nfrom preprocess.get_circle import get_dish\r\nfrom yolo_dish import yolo_dish\r\n\r\nclass DetectThread(QThread):\r\n    work_finished = pyqtSignal(object)  # 自定义信号，用于通知主线程转换完成\r\n\r\n    def __init__(self, work):\r\n        self.work = work\r\n        super(DetectThread, self).__init__()\r\n\r\n    def run(self):\r\n        result = self.work\r\n        self.work_finished.emit(result)  # 发送转换完成信号\r\n\r\nclass QTextEditHandler(logging.Handler):\r\n    def __init__(self, text_edit):\r\n        super(QTextEditHandler, self).__init__()\r\n        self.text_edit = text_edit\r\n        self.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))\r\n    def emit(self, record):\r\n        msg = self.format(record)\r\n        self.text_edit.append(msg)\r\n        QApplication.processEvents()\r\n\r\nclass myMainWindow(ToolkitUi,QMainWindow):\r\n    _signal = pyqtSignal\r\n\r\n    def __init__(self):\r\n\r\n        super(ToolkitUi,self).__init__()\r\n        self.setupUi(self)\r\n        self.timer = QTimer(self)\r\n        self._init_logger()\r\n        self.slot_init()\r\n        self.display_size = self.imageLabel.size()\r\n        self.csv_pairs = []\r\n        self.valid_images_format = ['jpg', 'tif', 'png', 'jpeg']\r\n\r\n    def slot_init(self):\r\n        self.openImageButton.clicked.connect(self.choose_image)\r\n        self.openImageDirButton.clicked.connect(self.open_directory)\r\n        self.LaunchButton.clicked.connect(self.detect)\r\n\r\n    def _init_logger(self):\r\n        self.LOGGER = logging.Logger(\"Bacteria Toolkit Logger\")\r\n        self.LOGGER.setLevel(logging.DEBUG)\r\n        current_datetime = datetime.datetime.now()\r\n        formatted_datetime = current_datetime.strftime(\"%Y-%m-%d_%H-%M-%S\")\r\n        self.run_path = os.path.join(ROOT, \"run\", formatted_datetime)\r\n        text_edit_handler = QTextEditHandler(self.textBrowser)\r\n        self.LOGGER.addHandler(text_edit_handler)\r\n\r\n        if not os.path.isdir(self.run_path):\r\n            os.mkdir(self.run_path)\r\n        log_file_path = os.path.join(self.run_path, \"UI.log\")\r\n        file_handler = logging.FileHandler(log_file_path)\r\n        self.LOGGER.addHandler(file_handler)\r\n\r\n    def choose_image(self):\r\n        self.input_image_path,_ = QFileDialog.getOpenFileName(self,\"选择图片\")\r\n        self.imgPathText.setText(self.input_image_path)\r\n        self.LOGGER.info(f\"Select {self.input_image_path}\")\r\n        try:\r\n            self.input_image = cv2.imread(self.input_image_path)\r\n            self._show_image(self.input_image)\r\n            self.current_image_path = self.input_image_path\r\n            img_name = os.path.basename(self.current_image_path)\r\n            self.current_image_name = \".\".join(img_name.split(\".\")[:-1])\r\n\r\n        except:\r\n            self.LOGGER.info(f\"Invalid,Please choose a Picture\")\r\n\r\n    def open_directory(self):\r\n        self.selected_dir = QFileDialog.getExistingDirectory(self)\r\n        try:\r\n            self.imgPathText.setText(self.selected_dir)\r\n            self.input_images_path = []\r\n\r\n            for item in os.listdir(self.selected_dir):\r\n                if os.path.basename(item).split('.')[-1].lower() in self.valid_images_format:\r\n                    self.input_images_path.append(os.path.join(self.selected_dir, item))\r\n            self.num_of_images = len(self.input_images_path)\r\n            self.LOGGER.info(f\"Detect there are {self.num_of_images} pictures at {self.selected_dir}\")\r\n        except:\r\n            self.LOGGER.info(f\"Invalid,Please choose a Directory\")\r\n\r\n\r\n    def detect(self):\r\n        self.output_images_path = os.path.join(self.run_path, \"images\")\r\n        if not os.path.isdir(self.output_images_path):\r\n            os.mkdir(self.output_images_path)\r\n        path = self.imgPathText.text()\r\n        if os.path.isdir(path):\r\n            index = 0\r\n            for image_path in self.input_images_path:\r\n                self.current_image_path = image_path\r\n                img_name = os.path.basename(self.current_image_path)\r\n                self.current_image_name = \".\".join(img_name.split(\".\")[:-1])\r\n                self.detect_dish(self.current_image_path)\r\n                index+=1\r\n                self._callback(int((index/self.num_of_images)*100))\r\n\r\n        elif os.path.isfile(path):\r\n            self.detect_dish(self.current_image_path)\r\n        # self.detect_bacteria(self.dish_img_path)\r\n\r\n    def detect_dish(self,img_path,yolo:bool=True):\r\n        \"\"\"\r\n        detect dish from img\r\n        :param img_path: image path\r\n        :return:\r\n        \"\"\"\r\n        img = cv2.imread(img_path)\r\n        if yolo:\r\n            # self.detect_circle_thread = DetectThread(yolo_dish(img_path,self.run_path))\r\n            [flag,img] = yolo_dish(img_path,self.run_path)\r\n            if not flag:\r\n                self.LOGGER.info(f\"Can't detect dish from {self.current_img_path}\")\r\n            dish_img_name = self.current_image_name + \"_dish.png\"\r\n            self.dish_img_path = os.path.join(self.output_images_path, dish_img_name)\r\n            cv2.imwrite(self.dish_img_path, img)\r\n            self.LOGGER.debug(f\"save preprocessed image at {self.dish_img_path}\")\r\n            self.detect_bacteria(self.dish_img_path)\r\n        else:\r\n            gray_img = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)\r\n            rows, cols = gray_img.shape\r\n            min_r = int(min(rows,cols)/5)\r\n            max_r = int(3*min(rows,cols)/5)\r\n            self.detect_circle_thread = DetectThread(get_dish(img=img,min_r=min_r,max_r=max_r))\r\n            self.detect_circle_thread.work_finished.connect(self.detect_dish_finished)\r\n            self.detect_circle_thread.start()\r\n            self.LOGGER.debug(f\"Trying to get dish from img {img_path}\")\r\n\r\n\r\n    def detect_dish_finished(self,result_list):\r\n        [flag,img] = result_list\r\n        self._show_image(img)\r\n        self.countLabel.setText(\"\")\r\n        self.detect_circle_thread.wait()\r\n        self.detect_circle_thread.quit()\r\n        self.detect_circle_thread.wait()\r\n        self.detect_circle_thread.deleteLater()\r\n        if not flag:\r\n            self.LOGGER.info(f\"Can't detect dish from {self.current_img_path}\")\r\n        dish_img_name = self.current_image_name + \"_dish.png\"\r\n        self.dish_img_path = os.path.join(self.output_images_path,dish_img_name)\r\n        cv2.imwrite(self.dish_img_path,img)\r\n        self.LOGGER.debug(f\"save preprocessed image at {self.dish_img_path}\")\r\n\r\n        self.detect_bacteria(self.dish_img_path)\r\n\r\n    def detect_bacteria(self,dish_img_path):\r\n        img = cv2.imread(dish_img_path)\r\n        opt = detect.parse_opt()\r\n        opt.imgsz = [int(img.shape[1]/32)*32,int(img.shape[0]/32)*32]\r\n        opt.project = self.run_path\r\n        opt.source = dish_img_path\r\n        opt.weights = os.path.join(ROOT,\"weights\",\"23-3-7.pt\")\r\n        # opt.cfg = os.path.join(ROOT,\"models\",\"YoloBcc.yaml\")\r\n        detect.run(**vars(opt))\r\n\r\n        self.result_csv = os.path.join(self.run_path, \"result.csv\")\r\n        self.labels_pth = os.path.join(self.run_path, \"exp\", \"labels\", self.current_image_name + \"_dish.txt\")\r\n        self.result_img = os.path.join(self.run_path, \"exp\", self.current_image_name + \"_dish.png\")\r\n        self.result_path = os.path.join(self.run_path, \"result\")\r\n        self.result_process()\r\n\r\n    def result_process(self):\r\n        if not os.path.isdir(self.result_path):\r\n            os.mkdir(self.result_path)\r\n        if os.path.isfile(self.labels_pth):\r\n            with open(self.labels_pth, \"r\") as f:\r\n                label_list = f.readlines()\r\n                bacteria_counts = len(label_list)\r\n                f.close()\r\n            _force_move(self.labels_pth,self.result_path)\r\n        else:\r\n            bacteria_counts = 0\r\n        self.csv_pairs.append([self.current_image_name + '.png', bacteria_counts])\r\n        self.LOGGER.info(f\"{self.current_image_name}.png 's bacteria num is {bacteria_counts}\")\r\n\r\n        with open(self.result_csv,'a') as f1:\r\n            f1.write(f\"{self.current_image_name}_dish.png,{bacteria_counts}\\n\")\r\n            f1.close()\r\n        result_img = cv2.imread(self.result_img)\r\n        self.countLabel.setText(f\"{bacteria_counts}\")\r\n        self._show_image(result_img)\r\n\r\n        _force_move(self.dish_img_path, self.result_path)\r\n        _force_move(self.result_img, self.output_images_path)\r\n        shutil.rmtree(os.path.join(self.run_path,\"exp\"))\r\n\r\n    def _show_image(self,input_image):\r\n        \"\"\"\r\n        display image on GUI\r\n        :param image: cv2 image\r\n        :return:\r\n        \"\"\"\r\n        display = cv2.resize(input_image, (self.display_size.width(), self.display_size.height()))\r\n        img = cv2.cvtColor(display,cv2.COLOR_BGR2RGB)\r\n        self.display_image = QtGui.QImage(img.data,img.shape[1],img.shape[0],QtGui.QImage.Format_RGB888)\r\n        self.imageLabel.setPixmap(QtGui.QPixmap.fromImage(self.display_image))\r\n        QApplication.processEvents()\r\n\r\n    def _callback(self,proc:int=0):\r\n        \"\"\"\r\n\r\n        :param proc:\r\n        :return:\r\n        \"\"\"\r\n        self.progressBar.setProperty(\"value\",proc)\r\n        QApplication.processEvents()\r\n\r\ndef _force_move(src_path:str,des_path:str):\r\n    \"\"\"\r\n    force move file ,if des_path exists src file,it will replace it\r\n    :param src_path:\r\n    :param des_path:\r\n    :return:\r\n    \"\"\"\r\n    src_base_name = os.path.basename(src_path)\r\n    if os.path.isfile(des_path):\r\n        if os.path.basename(des_path) == src_base_name:\r\n            os.remove(des_path)\r\n        else:\r\n            shutil.move(src_path,des_path)\r\n    elif os.path.isdir(des_path):\r\n        if os.path.isfile(os.path.join(des_path,src_base_name)):\r\n            os.remove(os.path.join(des_path,src_base_name))\r\n        else:\r\n            shutil.move(src_path,des_path)\r\n\r\nif __name__ == \"__main__\":\r\n    app = QApplication(sys.argv)\r\n    controller_gui = myMainWindow()\r\n    controller_gui.show()\r\n    sys.exit(app.exec_())
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/launch.py b/launch.py
--- a/launch.py	(revision 2c142bebebe238ebe7441e6165c8b72b032a0c51)
+++ b/launch.py	(date 1692581952425)
@@ -131,7 +131,7 @@
             # self.detect_circle_thread = DetectThread(yolo_dish(img_path,self.run_path))
             [flag,img] = yolo_dish(img_path,self.run_path)
             if not flag:
-                self.LOGGER.info(f"Can't detect dish from {self.current_img_path}")
+                self.LOGGER.info(f"Can't detect dish from {self.current_image_path}")
             dish_img_name = self.current_image_name + "_dish.png"
             self.dish_img_path = os.path.join(self.output_images_path, dish_img_name)
             cv2.imwrite(self.dish_img_path, img)
Index: .gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.gitignore b/.gitignore
--- a/.gitignore	(revision 2c142bebebe238ebe7441e6165c8b72b032a0c51)
+++ b/.gitignore	(date 1692347096915)
@@ -1,0 +1,2 @@
+/data/images/
+/weights/
\ No newline at end of file
